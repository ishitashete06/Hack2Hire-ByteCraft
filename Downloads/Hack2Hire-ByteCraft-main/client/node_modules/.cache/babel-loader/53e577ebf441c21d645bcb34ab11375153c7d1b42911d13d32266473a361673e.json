{"ast":null,"code":"import FontFaceObserver from \"fontfaceobserver\";\nimport { isString } from \"../../utils/utils.js\";\nconst FONT_LOADING_TIMEOUT = 5000; // Amount of ms to wait when detecting if a font is ready\nconst MAX_RETRIES = 3; // Max number of times to retry font loading in case network error occurs\nexport class FontLoadingError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"FontLoadingError\";\n  }\n}\nconst fontRequests = new Map();\nconst fontReadyPromises = new Map();\n/** @internal  */\nexport const loadFont = (data, doc) => loadFontWithRetries(data, doc);\nasync function loadFontWithRetries(data, doc, attempt = 0) {\n  const {\n    family,\n    url,\n    stretch,\n    unicodeRange\n  } = data;\n  const weight = data.weight || 500;\n  const style = data.style || \"normal\";\n  const requestId = `${family}-${style}-${weight}-${url}`;\n  if (!fontRequests.has(requestId) || attempt > 0) {\n    const fontFace = new FontFace(family, `url(${url})`, {\n      weight: isString(weight) ? weight : weight?.toString(),\n      style,\n      stretch,\n      unicodeRange\n    });\n    const readyPromise = fontFace\n    // Load the font\n    .load().then(() => {\n      // Add the font to the document\n      doc.fonts.add(fontFace);\n      // Wait until it's fully ready\n      return isFontReady(family, style, weight);\n    }).catch(e => {\n      if (e.name !== \"NetworkError\") {\n        throw e;\n      }\n      // In case of a network error; retry\n      if (attempt < MAX_RETRIES) {\n        return loadFontWithRetries(data, doc, attempt + 1);\n      }\n      // Throw error when retry limit has been reached\n      throw new FontLoadingError(`Font loading failed after ${attempt} retries due to network error: ${JSON.stringify({\n        family,\n        style,\n        weight,\n        url,\n        stretch,\n        unicodeRange\n      })}`);\n    });\n    fontRequests.set(requestId, readyPromise);\n  }\n  await fontRequests.get(requestId);\n}\n/** @internal  */\nexport async function isFontReady(family, style, weight) {\n  const readyPromiseId = `${family}-${style}-${weight}`;\n  if (!fontReadyPromises.has(readyPromiseId)) {\n    const observer = new FontFaceObserver(family, {\n      style,\n      weight\n    });\n    const readyPromise = observer.load(null, FONT_LOADING_TIMEOUT);\n    fontReadyPromises.set(readyPromiseId, readyPromise);\n  }\n  try {\n    await fontReadyPromises.get(readyPromiseId);\n  } catch (e) {\n    throw new FontLoadingError(`Failed to check if font is ready (${FONT_LOADING_TIMEOUT}ms timeout exceeded): ${JSON.stringify({\n      family,\n      style,\n      weight\n    })}`);\n  }\n}\n/**\n * @internal\n * Util function for use in tests to clear state between test cases\n * */\nexport function _clearCache() {\n  fontRequests.clear();\n  fontReadyPromises.clear();\n}","map":{"version":3,"names":["FontFaceObserver","isString","FONT_LOADING_TIMEOUT","MAX_RETRIES","FontLoadingError","Error","constructor","message","name","fontRequests","Map","fontReadyPromises","loadFont","data","doc","loadFontWithRetries","attempt","family","url","stretch","unicodeRange","weight","style","requestId","has","fontFace","FontFace","toString","readyPromise","load","then","fonts","add","isFontReady","catch","e","JSON","stringify","set","get","readyPromiseId","observer","_clearCache","clear"],"sources":["../../../src/render/fonts/loadFont.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}