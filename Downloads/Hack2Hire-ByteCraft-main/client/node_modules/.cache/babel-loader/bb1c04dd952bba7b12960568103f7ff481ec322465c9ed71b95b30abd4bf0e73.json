{"ast":null,"code":"import { interpolate } from \"framer-motion\";\nimport { Line } from \"../../render/types/Line.js\";\nimport { Point } from \"../../render/types/Point.js\";\nimport { Rect } from \"../../render/types/Rect.js\";\nimport { assert } from \"../../utils/assert.js\";\nimport { ConvertColor } from \"../types/Color/ConvertColor.js\";\nimport { LinearGradient, RadialGradient } from \"../types/Gradient.js\";\nimport { gradientColorStops } from \"./gradientColorStops.js\";\n/**\n * Get a line made up of the 2 points where a line from the center of the layer\n * along the angle of the gradient would intersect with a 1x1 rectangle.\n */\nfunction linearGradientLine(angle) {\n  const rad = angle * Math.PI / 180;\n  const offset = {\n    x: -Math.sin(rad) * 100,\n    y: Math.cos(rad) * 100\n  };\n  const anglePoint = Point(offset.x, offset.y);\n  const angleLine = Line(Point(0.5, 0.5), anglePoint);\n  // Get points from a 1x1 rectangle.\n  const points = Rect.points({\n    x: 0,\n    y: 0,\n    width: 1,\n    height: 1\n  });\n  // Find the two closest points. These should always be the points that form\n  // the side of the 1x1 square that the angled line travels through. This is\n  // only true because we are using a square, and would not hold true for a\n  // rectangle.\n  const sortedPoints = points.map(point => ({\n    point,\n    distance: Point.distance(anglePoint, point)\n  })).sort((a, b) => a.distance - b.distance);\n  const a = sortedPoints[0]?.point;\n  const b = sortedPoints[1]?.point;\n  assert(a && b, \"linearGradientLine: Must have 2 closest points.\");\n  // Find the other points, together they should form the line of the opposing side.\n  const [c, d] = points.filter(point => !Point.isEqual(point, a) && !Point.isEqual(point, b));\n  assert(c && d, \"linearGradientLine: Must have 2 opposing points.\");\n  // The start and end point of the line of the gradient are defined by where\n  // the angle line would intersect with our sides.\n  const start = Line.intersection(angleLine, Line(a, b));\n  const end = Line.intersection(angleLine, Line(c, d));\n  assert(start && end, \"linearGradientLine: Must have a start and end point.\");\n  return Line(start, end);\n}\nexport function elementPropertiesForLinearGradient(gradient, id) {\n  const line = linearGradientLine(gradient.angle);\n  const stops = gradientColorStops(gradient);\n  const startPosition = stops[0]?.position ?? 0;\n  const endPosition = stops[stops.length - 1]?.position ?? 1;\n  const startPoint = Line.pointAtPercentDistance(line, startPosition);\n  const endPoint = Line.pointAtPercentDistance(line, endPosition);\n  // Since the gradient will be positioned by the coordinates of the start and\n  // end point, we normalize the other points into that range.\n  const interpolator = interpolate([startPosition, endPosition], [0, 1]);\n  return {\n    id: `id${id}g${LinearGradient.hash(gradient)}`,\n    x1: startPoint.x,\n    y1: startPoint.y,\n    x2: endPoint.x,\n    y2: endPoint.y,\n    stops: stops.map(stop => ({\n      color: stop.value,\n      alpha: ConvertColor.getAlpha(stop.value) * gradient.alpha,\n      position: interpolator(stop.position)\n    }))\n  };\n}\nexport function elementPropertiesForRadialGradient(gradient, id) {\n  return {\n    id: `id${id}g${RadialGradient.hash(gradient)}`,\n    widthFactor: gradient.widthFactor,\n    heightFactor: gradient.heightFactor,\n    centerAnchorX: gradient.centerAnchorX,\n    centerAnchorY: gradient.centerAnchorY,\n    stops: gradientColorStops(gradient).map(stop => ({\n      color: stop.value,\n      alpha: ConvertColor.getAlpha(stop.value) * gradient.alpha,\n      position: stop.position\n    }))\n  };\n}","map":{"version":3,"names":["interpolate","Line","Point","Rect","assert","ConvertColor","LinearGradient","RadialGradient","gradientColorStops","linearGradientLine","angle","rad","Math","PI","offset","x","sin","y","cos","anglePoint","angleLine","points","width","height","sortedPoints","map","point","distance","sort","a","b","c","d","filter","isEqual","start","intersection","end","elementPropertiesForLinearGradient","gradient","id","line","stops","startPosition","position","endPosition","length","startPoint","pointAtPercentDistance","endPoint","interpolator","hash","x1","y1","x2","y2","stop","color","value","alpha","getAlpha","elementPropertiesForRadialGradient","widthFactor","heightFactor","centerAnchorX","centerAnchorY"],"sources":["../../../src/render/utils/elementPropertiesForGradient.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}