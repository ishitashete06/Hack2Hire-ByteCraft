{"ast":null,"code":"import React, { useCallback, useContext, useMemo, useRef } from \"react\";\nimport { assert } from \"../../utils/assert.js\";\n/**\n * @internal\n */\nexport const LayoutIdContext = React.createContext({\n  getLayoutId: args => null,\n  persistLayoutIdCache: () => {},\n  top: false,\n  enabled: true\n});\n// FIXME: This pattern currently not supported by rules-of-hooks, see\n// https://github.com/facebook/react/pull/18341#issuecomment-749659456\n/* eslint-disable react-hooks/rules-of-hooks */\n/**\n * @internal\n */\nexport function LayoutIdProvider({\n  children\n}) {\n  const context = useContext(LayoutIdContext);\n  // Since Code Components on the canvas can use Navigation, we need to ensure\n  // that only the root LayoutIdContext is generating layoutIds so that the\n  // cache is shared across all screens.\n  if (context.top) return React.createElement(React.Fragment, null, children);\n  const cache = useRef({\n    // When we provide a layoutId for a node based on it's first\n    // duplicatedFrom id, we save it's layoutId mapped to it's actual id.\n    // Future screen's nodes will check this cache first, to see if they've\n    // previously been assigned a layoutId, or if any of there other\n    // duplicatedFrom ids matched a node that was previously assigned a\n    // layoutId.\n    byId: {},\n    byName: {},\n    // When we navigate from screens that were duplicated from a future\n    // screen, to that future screen, we want to do a reverse lookup on the\n    // last duplicatedFrom id, rather than the id. We need to keep them\n    // separate so they don't overlap.\n    byLastId: {},\n    byPossibleId: {},\n    byLastName: {},\n    byLayoutId: {},\n    // When we don't have a cached layoutId for all duplicatedFrom ids, we\n    // need to increment and save it so that we don't create clashing\n    // layoutIds. We also need to reset name counts between screens, so we\n    // record those separately.\n    count: {\n      byId: {},\n      byName: {}\n    }\n  });\n  const screen = useRef({\n    byId: {},\n    byName: {},\n    byLastId: {},\n    byPossibleId: {},\n    byLastName: {},\n    byLayoutId: {}\n  });\n  // Keep track of which layoutIds have been used on the current screen so\n  // that we avoid reassigning them, and instead, use other methods to\n  // generate a unique id.\n  const usedIds = useRef(new Set()).current;\n  // This function is quite abstract so I've done my best to annotate why\n  // checks are happening. A lot of the complexity comes from handling named\n  // and unnamed layers differently.\n  const getLayoutId = useCallback(({\n    id,\n    name,\n    duplicatedFrom\n  }) => {\n    // Code components that use Frame's should not receive a layout id\n    // from our context. However this will be bypassed if end-users add an\n    // id to their Frame in code.\n    if (!id) return null;\n    const cacheKey = name ? \"byName\" : \"byId\";\n    // If we've previously recorded an layout id for this node, reuse it\n    // and return early.\n    const previousId = cache.current[cacheKey][id];\n    if (previousId) return previousId;\n    // If the node is an original node (hasn't been duplicated from another\n    // node), we use it's name or id, unless it's name or id was already\n    // used on this screen, or used by a node that wasn't last duplicated\n    // from this node on the previous screen (suggesting another node on\n    // this screen will need to use this id in a future call).\n    const nodeIdentifier = name || id;\n    if (!duplicatedFrom && !usedIds.has(nodeIdentifier) && (!cache.current.byLayoutId[nodeIdentifier] || cache.current.byLayoutId[nodeIdentifier] === nodeIdentifier)) {\n      if (cache.current.count[cacheKey][nodeIdentifier] === undefined) {\n        cache.current.count[cacheKey][nodeIdentifier] = 0;\n        cache.current.byLayoutId[nodeIdentifier] = nodeIdentifier;\n        screen.current[cacheKey][id] = nodeIdentifier;\n      }\n      usedIds.add(nodeIdentifier);\n      return nodeIdentifier;\n    }\n    // If a node is duplicated, check if an layout id was assigned to it\n    // on the last screen. Use that layout id if it's not already been\n    // used on this screen. This ensures that nodes duplicated from a\n    // specific layer on one screen, preserve their connection even if they\n    // are in a different hierarchical order on the current screen. This is\n    // not relevant for design components since their layers are always in\n    // the same order. We also check for matches against `byLastId`, but\n    // only use them after we explicitly check `id`.\n    let possibleMatch = undefined;\n    if (duplicatedFrom?.length) {\n      for (let index = duplicatedFrom.length - 1; index >= 0; index--) {\n        const duplicatedId = duplicatedFrom[index];\n        assert(!!duplicatedId, `duplicatedId must be defined`);\n        const match = cache.current[cacheKey][duplicatedId];\n        const byLastIdMatch = cache.current.byLastId[duplicatedId];\n        // In the event that no match is found for the duplicatedFrom id\n        // in the `byId` or `byName` cache, it's possible we will need\n        // to loop through the duplicatedFrom ids again, to check if\n        // there is a match against the `byLastId` cache. Rather than\n        // performing that loop again, we can save the first successful\n        // match here, and use it when it's the correct option later.\n        // This is safe because we will only use this match if there is\n        // no match against `byId` or `byName`, meaning we will always\n        // have looped through all of the duplicatedFrom ids.\n        if (byLastIdMatch && !possibleMatch) {\n          const matchedLayoutId = cache.current.byLayoutId[byLastIdMatch];\n          const shouldUseNamedLastIdMatch = !matchedLayoutId || matchedLayoutId === name;\n          if (byLastIdMatch && !usedIds.has(byLastIdMatch) && (name ? shouldUseNamedLastIdMatch : true)) {\n            possibleMatch = [byLastIdMatch, duplicatedId];\n          }\n        }\n        // If the match from the previous screen is a name match, ensure it is was assigned to the exact same name.\n        const previousLayoutId = cache.current.byLayoutId[match];\n        const shouldUseNamedMatch = !previousLayoutId || previousLayoutId === name;\n        if (match && !usedIds.has(match) && (name ? shouldUseNamedMatch : true)) {\n          screen.current[cacheKey][id] = match;\n          screen.current.byLastId[duplicatedId] = match;\n          usedIds.add(match);\n          return match;\n        }\n      }\n    }\n    // In cases where we're starting on a screen that uses frames duplicated\n    // from a future screen, when we arrive on the future screen, we need to\n    // make sure we preserve that connection. This handles direct\n    // relationships. For example starting on a frame that was duplicated\n    // directly from the previous frame, and transitioning to that previous\n    // frame.\n    const last = cache.current.byLastId[id];\n    if (last && !usedIds.has(last)) {\n      usedIds.add(last);\n      screen.current.byId[id] = last;\n      return last;\n    }\n    // If we set a possible match by checking duplicatedFrom ids against\n    // `byLastId`, and we weren't able to find a match against the `byId` or\n    // `byName`, or by directly looking up the node's id against `byLastId`,\n    // use a possible match if it was set.\n    if (possibleMatch) {\n      const [match, duplicatedId] = possibleMatch;\n      screen.current[cacheKey][id] = match;\n      screen.current.byLastId[duplicatedId] = match;\n      usedIds.add(match);\n      return match;\n    }\n    // In cases where we're starting on a screen that uses frames duplicated\n    // from a future screen, when we arrive on the future screen, we need to\n    // make sure we preserve that connection. This handles indirect\n    // relationships. For example starting on the last frame duplicated many\n    // times from an initial frame, and transitioning directly to that\n    // initial frame.\n    const possible = cache.current.byPossibleId[id];\n    if (possible && !usedIds.has(possible)) {\n      usedIds.add(possible);\n      screen.current.byId[id] = possible;\n      return possible;\n    }\n    const rootDuplicatedId = duplicatedFrom?.[0];\n    // If a node hasn't been assigned a layout id on a previous screen,\n    // or if that layout id has already been used, or if this is the\n    // first screen, generate a unique layout id by incrementing a\n    // counter for that name or duplicatedId.\n    const identifier = name || rootDuplicatedId || id;\n    const value = cache.current.count[cacheKey][identifier] + 1 || 0;\n    const {\n      layoutId,\n      value: nextValue\n    } = nextLayoutId(identifier, value, usedIds);\n    cache.current.count[cacheKey][identifier] = nextValue;\n    screen.current[cacheKey][id] = layoutId;\n    if (duplicatedFrom?.length) {\n      // TODO: Should name use it's own map?\n      if (!name) {\n        const lastId = duplicatedFrom[duplicatedFrom.length - 1];\n        if (lastId) {\n          screen.current.byLastId[lastId] = layoutId;\n        }\n        if (duplicatedFrom.length > 1) {\n          // Skipping the most recent duplicatedFrom, and only setting\n          // it if there isn't already one set. This isn't a perfect\n          // heuristic since it allows layout hierarchy to influence\n          // matches, since we have to assign on a\n          // first-come-first-serve basis.\n          for (let index = 0; index < duplicatedFrom.length - 1; index++) {\n            const possibleId = duplicatedFrom[index];\n            if (possibleId === undefined) continue;\n            if (!screen.current.byPossibleId[possibleId]) {\n              screen.current.byPossibleId[possibleId] = layoutId;\n            }\n          }\n        }\n      }\n    }\n    screen.current.byLayoutId[layoutId] = nodeIdentifier;\n    usedIds.add(layoutId);\n    return layoutId;\n  }, []);\n  const persistLayoutIdCache = useCallback(() => {\n    cache.current = {\n      byId: {\n        ...cache.current.byId,\n        ...screen.current.byId\n      },\n      byLastId: {\n        ...cache.current.byLastId,\n        ...screen.current.byLastId\n      },\n      byPossibleId: {\n        ...cache.current.byPossibleId,\n        ...screen.current.byPossibleId\n      },\n      byName: {\n        ...cache.current.byName,\n        ...screen.current.byName\n      },\n      byLastName: {\n        ...cache.current.byLastName,\n        ...screen.current.byLastName\n      },\n      byLayoutId: {\n        ...cache.current.byLayoutId,\n        ...screen.current.byLayoutId\n      },\n      // Unlike the count.byId, we need to reset the count.byName because\n      // named layers might not have duplicatedFrom ids (e.g. imported\n      // from Figma). When we can use duplicatedFrom ids to check if an id\n      // was assigned on a previous screen, we don't increment the count,\n      // which means that the count only increments for new items, and\n      // only increments on a new screen if the node is new. Since named\n      // layers need to always match in some way between screens, we reset\n      // the count so that the second named layer on a second screen is\n      // always name-1 if it doesn't have any duplicatedFrom ids.\n      count: {\n        ...cache.current.count,\n        byName: {}\n      }\n    };\n    screen.current = {\n      byId: {},\n      byName: {},\n      byLastId: {},\n      byPossibleId: {},\n      byLastName: {},\n      byLayoutId: {}\n    };\n    usedIds.clear();\n  }, []);\n  // Bind the context value to a ref so that it doesn't change between\n  // renders, which cases all subscribed descendants to update.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const contextValue = useRef({\n    getLayoutId,\n    persistLayoutIdCache,\n    top: true,\n    enabled: true\n  }).current;\n  return React.createElement(LayoutIdContext.Provider, {\n    value: contextValue\n  }, children);\n}\n// FIXME (See top of function)\n/* eslint-enable react-hooks/rules-of-hooks */\nfunction nextLayoutId(identifier, initialValue, usedIds) {\n  let value = initialValue;\n  // We expect 0 to be falsy here so that generated ids match with\n  // original ids.\n  let layoutId = value ? `${identifier}-${value}` : identifier;\n  while (usedIds.has(layoutId)) {\n    value++;\n    layoutId = `${identifier}-${value}`;\n  }\n  return {\n    layoutId,\n    value\n  };\n}\n/**\n * Enable or disable the automatic generation of layout ids for canvas layers.\n * By default layout ids are generated for all layers created on the Framer\n * canvas. However, layout ids are not generated for any layer that is a\n * descendant of a code component. Sometimes you will want to enable layout id\n * generation for descendants of your code components when they use children,\n * slots, or import design components, and you want those layers to animate with\n * magic motion transitions.\n *\n * You can enable that behavior by wrapping your code component like this\n * ```typescript\n * <AutomaticLayoutIds enabled>\n *  <YourComponent/>\n * </AutomaticLayoutIds>\n * ```\n * @public\n */\nexport function AutomaticLayoutIds({\n  enabled = true,\n  ...props\n}) {\n  const context = useContext(LayoutIdContext);\n  const contextValue = useMemo(() => {\n    return {\n      ...context,\n      enabled\n    };\n  }, [enabled]);\n  return React.createElement(LayoutIdContext.Provider, {\n    ...props,\n    value: contextValue\n  });\n}","map":{"version":3,"names":["React","useCallback","useContext","useMemo","useRef","assert","LayoutIdContext","createContext","getLayoutId","args","persistLayoutIdCache","top","enabled","LayoutIdProvider","children","context","createElement","Fragment","cache","byId","byName","byLastId","byPossibleId","byLastName","byLayoutId","count","screen","usedIds","Set","current","id","name","duplicatedFrom","cacheKey","previousId","nodeIdentifier","has","undefined","add","possibleMatch","length","index","duplicatedId","match","byLastIdMatch","matchedLayoutId","shouldUseNamedLastIdMatch","previousLayoutId","shouldUseNamedMatch","last","possible","rootDuplicatedId","identifier","value","layoutId","nextValue","nextLayoutId","lastId","possibleId","clear","contextValue","Provider","initialValue","AutomaticLayoutIds","props"],"sources":["../../../src/components/AnimateLayout/LayoutIdContext.tsx"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}