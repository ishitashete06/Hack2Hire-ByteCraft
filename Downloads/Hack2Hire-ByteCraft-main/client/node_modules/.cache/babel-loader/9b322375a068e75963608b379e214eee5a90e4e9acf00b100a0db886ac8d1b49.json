{"ast":null,"code":"import { SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE } from \"../../components/hoc/withMeasuredSize.js\";\n/**\n * @internal\n *\n * Returns a plain array of references to all children, which should be\n * considered for content size calculations on this node (e.g. when running \"Fit\n * Content\" on it)\n *\n * @param element the element of the component container\n */\nexport function getMeasurableCodeComponentChildren(element) {\n  // Skip over withMeasuredSize compatibility wrapper\n  const childrenCollection = element.firstElementChild && element.firstElementChild.hasAttribute(SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE) ? element.firstElementChild.children : element.children;\n  return [...childrenCollection].filter(isMeasurable).map(unwrapInlinedDisplayContents);\n}\n/**\n * Rough check if an element of a HTMLCollection has measurable layout (can be\n * rendered as anything other than \"display: none\") _without_ querying its\n * computed styles, because we want to avoid a style recalculation penalty.\n *\n * @param element an HTMLCollection node\n */\nfunction isMeasurable(element) {\n  // Filter out certain HTMLElement subclasses that don't represent measurable elements\n  if (element instanceof HTMLBaseElement || element instanceof HTMLHeadElement || element instanceof HTMLLinkElement || element instanceof HTMLMetaElement || element instanceof HTMLScriptElement || element instanceof HTMLStyleElement || element instanceof HTMLTitleElement) {\n    return false;\n  }\n  return element instanceof HTMLElement || element instanceof SVGElement;\n}\n/**\n * Checks if an element has \"display: contents\" in its inline styles, and if\n * yes, returns the first measurable descendant. We intentionally _only_ check\n * the inlined display style, because reading it should not cause a style recalc\n * and it covers the use cases we have right now - wrapper divs around smart\n * components.\n *\n * @param element\n * @returns\n */\nfunction unwrapInlinedDisplayContents(element) {\n  if (!(element instanceof HTMLElement)) return element;\n  if (element.children.length === 0) return element;\n  if (element.style.display !== \"contents\") return element;\n  const firstMeasurableChild = [...element.children].find(isMeasurable);\n  if (firstMeasurableChild) {\n    return unwrapInlinedDisplayContents(firstMeasurableChild);\n  }\n  return element;\n}","map":{"version":3,"names":["SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE","getMeasurableCodeComponentChildren","element","childrenCollection","firstElementChild","hasAttribute","children","filter","isMeasurable","map","unwrapInlinedDisplayContents","HTMLBaseElement","HTMLHeadElement","HTMLLinkElement","HTMLMetaElement","HTMLScriptElement","HTMLStyleElement","HTMLTitleElement","HTMLElement","SVGElement","length","style","display","firstMeasurableChild","find"],"sources":["../../../src/render/utils/getMeasurableCodeComponentChildren.ts"],"sourcesContent":[null],"mappings":"AAAA,SAASA,oCAAoC,QAAQ,0CAA0C;AAE/F;;;;;;;;;AASA,OAAM,SAAUC,kCAAkCA,CAACC,OAAgB;EAC/D;EACA,MAAMC,kBAAkB,GACpBD,OAAO,CAACE,iBAAiB,IAAIF,OAAO,CAACE,iBAAiB,CAACC,YAAY,CAACL,oCAAoC,CAAC,GACnGE,OAAO,CAACE,iBAAiB,CAACE,QAAQ,GAClCJ,OAAO,CAACI,QAAQ;EAE1B,OAAO,CAAC,GAAGH,kBAAkB,CAAC,CAACI,MAAM,CAACC,YAAY,CAAC,CAACC,GAAG,CAACC,4BAA4B,CAAC;AACzF;AAEA;;;;;;;AAQA,SAASF,YAAYA,CAACN,OAAa;EAC/B;EACA,IACIA,OAAO,YAAYS,eAAe,IAClCT,OAAO,YAAYU,eAAe,IAClCV,OAAO,YAAYW,eAAe,IAClCX,OAAO,YAAYY,eAAe,IAClCZ,OAAO,YAAYa,iBAAiB,IACpCb,OAAO,YAAYc,gBAAgB,IACnCd,OAAO,YAAYe,gBAAgB,EACrC;IACE,OAAO,KAAK;;EAGhB,OAAOf,OAAO,YAAYgB,WAAW,IAAIhB,OAAO,YAAYiB,UAAU;AAC1E;AAEA;;;;;;;;;;AAWA,SAAST,4BAA4BA,CAACR,OAAgB;EAClD,IAAI,EAAEA,OAAO,YAAYgB,WAAW,CAAC,EAAE,OAAOhB,OAAO;EACrD,IAAIA,OAAO,CAACI,QAAQ,CAACc,MAAM,KAAK,CAAC,EAAE,OAAOlB,OAAO;EACjD,IAAIA,OAAO,CAACmB,KAAK,CAACC,OAAO,KAAK,UAAU,EAAE,OAAOpB,OAAO;EAExD,MAAMqB,oBAAoB,GAAG,CAAC,GAAGrB,OAAO,CAACI,QAAQ,CAAC,CAACkB,IAAI,CAAChB,YAAY,CAAC;EACrE,IAAIe,oBAAoB,EAAE;IACtB,OAAOb,4BAA4B,CAACa,oBAAoB,CAAC;;EAG7D,OAAOrB,OAAO;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}