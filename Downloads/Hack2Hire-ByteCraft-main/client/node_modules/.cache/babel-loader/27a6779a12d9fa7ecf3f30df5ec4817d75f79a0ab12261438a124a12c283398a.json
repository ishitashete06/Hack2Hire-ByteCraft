{"ast":null,"code":"import { useRef } from \"react\";\nimport { isEqual } from \"../render/utils/isEqual.js\";\nimport { isArray, isNumber, isObject, isString, isUndefined, isValidDate } from \"../utils/utils.js\";\nimport { LazyValue } from \"./LazyValue.js\";\n/** A DeepWeakMap is a WeakMap of WeakMaps. */\nexport class DeepWeakMap {\n  map1 = new WeakMap();\n  get(key1, key2) {\n    const map2 = this.map1.get(key1);\n    return map2?.get(key2);\n  }\n  set(key1, key2, value) {\n    const map2 = this.map1.get(key1) ?? new WeakMap();\n    this.map1.set(key1, map2);\n    return map2.set(key2, value);\n  }\n}\nexport var UnaryOperator;\n(function (UnaryOperator) {\n  UnaryOperator[\"Not\"] = \"not\";\n})(UnaryOperator || (UnaryOperator = {}));\nexport var BinaryOperator;\n(function (BinaryOperator) {\n  BinaryOperator[\"And\"] = \"and\";\n  BinaryOperator[\"Or\"] = \"or\";\n  BinaryOperator[\"Equals\"] = \"==\";\n  BinaryOperator[\"NotEquals\"] = \"!=\";\n  BinaryOperator[\"LessThan\"] = \"<\";\n  BinaryOperator[\"LessThanOrEqual\"] = \"<=\";\n  BinaryOperator[\"GreaterThan\"] = \">\";\n  BinaryOperator[\"GreaterThanOrEqual\"] = \">=\";\n})(BinaryOperator || (BinaryOperator = {}));\nexport var OrderDirection;\n(function (OrderDirection) {\n  OrderDirection[\"Ascending\"] = \"asc\";\n  OrderDirection[\"Descending\"] = \"desc\";\n})(OrderDirection || (OrderDirection = {}));\n// Extract the data from collection module.\nfunction useData(from) {\n  const {\n    data,\n    locale\n  } = from;\n  // The collection is not localized. Return the data directly.\n  if (isArray(data)) return data;\n  // The collection is localized. Preload the locale.\n  const promise = data.preload(locale);\n  if (promise) throw promise;\n  return data.read(locale);\n}\n// Insert \"index\" field into data.\nconst indexCache = new WeakMap();\nfunction useInsertIndex(data) {\n  const cached = indexCache.get(data);\n  if (cached) return cached;\n  const result = data.map((item, index) => {\n    return {\n      ...item,\n      index\n    };\n  });\n  indexCache.set(data, result);\n  return result;\n}\n// Handle \"WHERE …\" expression.\nconst whereCache = /* @__PURE__ */new DeepWeakMap();\nfunction useExecuteWhere(data, where) {\n  if (!where) return data;\n  const cached = whereCache.get(data, where);\n  if (cached) return cached;\n  const result = data.filter(item => {\n    return evaluateExpression(where, {\n      resolveIdentifier(identifier) {\n        return item[identifier];\n      }\n    });\n  });\n  whereCache.set(data, where, result);\n  return result;\n}\n// Handle \"ORDER BY …\" expression.\nconst orderByCache = /* @__PURE__ */new DeepWeakMap();\nfunction useExecuteOrderBy(data, orderBy) {\n  if (!orderBy) return data;\n  const cached = orderByCache.get(data, orderBy);\n  if (cached) return cached;\n  const result = [...data].sort((leftItem, rightItem) => {\n    let order = 0;\n    for (const expression of orderBy) {\n      const leftValue = evaluateExpression(expression, {\n        resolveIdentifier(identifier) {\n          return leftItem[identifier];\n        }\n      });\n      const rightValue = evaluateExpression(expression, {\n        resolveIdentifier(identifier) {\n          return rightItem[identifier];\n        }\n      });\n      if (isNumber(leftValue) && isNumber(rightValue)) {\n        order = leftValue - rightValue;\n      }\n      if (isString(leftValue) && isString(rightValue)) {\n        order = leftValue.localeCompare(rightValue, \"en\");\n      }\n      if (order !== 0) {\n        return expression.direction === OrderDirection.Descending ? -order : order;\n      }\n    }\n    if (isNumber(leftItem.index) && isNumber(rightItem.index)) {\n      return leftItem.index - rightItem.index;\n    }\n    return 0;\n  });\n  orderByCache.set(data, orderBy, result);\n  return result;\n}\n// Handle \"OFFSET …\" expression.\nconst offsetCache = /* @__PURE__ */new DeepWeakMap();\nfunction useExecuteOffset(data, offset) {\n  if (!offset) return data;\n  const cached = offsetCache.get(data, offset);\n  if (cached) return cached;\n  const offsetValue = evaluateExpression(offset, {\n    resolveIdentifier() {\n      // We can't resolve an identifier in this place yet. In the\n      // future we should be able to resolve something like COUNT(*)\n      // or SUM(population).\n      throw new Error(\"Can't resolve identifier\");\n    }\n  });\n  const result = isNumber(offsetValue) ? data.slice(offsetValue) : data;\n  offsetCache.set(data, offset, result);\n  return result;\n}\n// Handle \"LIMIT …\" expression.\nconst limitCache = /* @__PURE__ */new DeepWeakMap();\nfunction useExecuteLimit(data, limit) {\n  if (!limit) return data;\n  const cached = limitCache.get(data, limit);\n  if (cached) return cached;\n  const limitValue = evaluateExpression(limit, {\n    resolveIdentifier() {\n      throw new Error(\"Can't resolve identifier\");\n    }\n  });\n  const result = isNumber(limitValue) ? data.slice(0, limitValue) : data;\n  limitCache.set(data, limit, result);\n  return result;\n}\n// Handle \"SELECT …\" expression.\nconst selectCache = /* @__PURE__ */new DeepWeakMap();\nfunction useExecuteSelect(data, select) {\n  const cached = selectCache.get(data, select);\n  if (cached) return cached;\n  const preloadPromise = preloadExpressions(select, data);\n  // Throw promise which React will catch and wait until it's resolved before\n  // attempting re-rendering. This is an unofficial API, currently used\n  // internally by `React.lazy`.\n  if (preloadPromise) throw preloadPromise;\n  const result = data.map(item => {\n    const selected = {};\n    for (const expression of select) {\n      const name = expression.alias ?? stringifyExpression(expression);\n      selected[name] = evaluateExpression(expression, {\n        resolveIdentifier(identifier) {\n          const value = item[identifier];\n          if (LazyValue.is(value)) {\n            return value.read();\n          }\n          return value;\n        }\n      });\n    }\n    return selected;\n  });\n  selectCache.set(data, select, result);\n  return result;\n}\nfunction preloadExpressions(expressions, data) {\n  // Get all the identifiers that are used by the expressions so we don't have\n  // to iterate over the whole expression in the for loop below.\n  const identifiers = [];\n  for (const expression of expressions) {\n    extractIdentifiers(identifiers, expression);\n  }\n  // If we don't have any identifiers in the expressions there is no need to\n  // preload anything.\n  if (identifiers.length === 0) return;\n  // Collect a promise for every lazy value that needs to be preloaded.\n  const preloadPromises = [];\n  for (const item of data) {\n    for (const identifier of identifiers) {\n      const value = item[identifier];\n      if (!LazyValue.is(value)) continue;\n      const promise = value.preload();\n      if (!promise) continue;\n      preloadPromises.push(promise);\n    }\n  }\n  // Return a promise that resolves when all the lazy values are preloaded.\n  if (preloadPromises.length === 0) return;\n  return Promise.all(preloadPromises);\n}\nfunction extractIdentifiers(identifiers, expression) {\n  if (expression.type === \"Identifier\") {\n    identifiers.push(expression.name);\n  }\n  if (expression.type === \"FunctionCall\") {\n    for (const argument of expression.arguments) {\n      extractIdentifiers(identifiers, argument);\n    }\n  }\n  if (expression.type === \"Case\") {\n    if (expression.value) {\n      extractIdentifiers(identifiers, expression.value);\n    }\n    for (const condition of expression.conditions) {\n      extractIdentifiers(identifiers, condition.when);\n      extractIdentifiers(identifiers, condition.then);\n    }\n    if (expression.else) {\n      extractIdentifiers(identifiers, expression.else);\n    }\n  }\n  if (expression.type === \"UnaryOperation\") {\n    extractIdentifiers(identifiers, expression.value);\n  }\n  if (expression.type === \"BinaryOperation\") {\n    extractIdentifiers(identifiers, expression.left);\n    extractIdentifiers(identifiers, expression.right);\n  }\n  if (expression.type === \"TypeCast\") {\n    extractIdentifiers(identifiers, expression.value);\n  }\n}\n/** @internal */\nexport function useQueryData(query) {\n  const queryRef = useRef();\n  // Save a stable reference to the query if it hasn't changed so the useMemo\n  // below works correctly. TODO: This doesn't work with suspense.\n  if (queryRef.current && isEqual(queryRef.current, query)) {\n    query = queryRef.current;\n  } else {\n    queryRef.current = query;\n  }\n  let result = useData(query.from);\n  // We can't use useMemo here as it doesn't work if the component suspends.\n  // To cache the steps we store the result of each step on the previous\n  // result object with a WeakMap instead.\n  result = useInsertIndex(result);\n  result = useExecuteWhere(result, query.where);\n  result = useExecuteOrderBy(result, query.orderBy);\n  result = useExecuteOffset(result, query.offset);\n  result = useExecuteLimit(result, query.limit);\n  result = useExecuteSelect(result, query.select);\n  return result;\n}\nexport function evaluateExpression(expression, context) {\n  switch (expression.type) {\n    case \"Identifier\":\n      return context.resolveIdentifier(expression.name);\n    case \"LiteralValue\":\n      return expression.value;\n    case \"FunctionCall\":\n      return evaluateFunctionCall(expression, context);\n    case \"Case\":\n      return evaluateCase(expression, context);\n    case \"UnaryOperation\":\n      return evaluateUnaryOperation(expression, context);\n    case \"BinaryOperation\":\n      return evaluateBinaryOperation(expression, context);\n    case \"TypeCast\":\n      return evaluateTypeCast(expression, context);\n    default:\n      throw new Error(`Unsupported expression: ${JSON.stringify(expression)}`);\n  }\n}\nfunction evaluateFunctionCall(expression, context) {\n  function getArgument(index) {\n    const argument = expression.arguments[index];\n    if (argument) {\n      return evaluateExpression(argument, context);\n    }\n  }\n  switch (expression.functionName) {\n    case \"CONTAINS\":\n      {\n        const value = getArgument(0);\n        const search = getArgument(1);\n        if (isString(value) && isString(search)) {\n          return value.toLowerCase().includes(search.toLowerCase());\n        }\n        return false;\n      }\n    case \"STARTS_WITH\":\n      {\n        const value = getArgument(0);\n        const search = getArgument(1);\n        if (isString(value) && isString(search)) {\n          return value.toLowerCase().startsWith(search.toLowerCase());\n        }\n        return false;\n      }\n    case \"ENDS_WITH\":\n      {\n        const value = getArgument(0);\n        const search = getArgument(1);\n        if (isString(value) && isString(search)) {\n          return value.toLowerCase().endsWith(search.toLowerCase());\n        }\n        return false;\n      }\n    default:\n      {\n        throw new Error(`Unsupported function: ${expression.functionName}`);\n      }\n  }\n}\nfunction evaluateCase(expression, context) {\n  const value = expression.value && evaluateExpression(expression.value, context);\n  for (const condition of expression.conditions) {\n    const when = evaluateExpression(condition.when, context);\n    // If there is a value given in the case expression we check for\n    // equality. Otherwise, we check if the condition is truthy.\n    if (expression.value ? isLooseEqual(when, value) : when) {\n      return evaluateExpression(condition.then, context);\n    }\n  }\n  if (expression.else) {\n    return evaluateExpression(expression.else, context);\n  }\n}\nfunction evaluateUnaryOperation(expression, context) {\n  const value = evaluateExpression(expression.value, context);\n  switch (expression.operator) {\n    case UnaryOperator.Not:\n      {\n        return !value;\n      }\n    default:\n      {\n        throw new Error(`Unsupported unary operation: ${expression.operator}`);\n      }\n  }\n}\nfunction evaluateBinaryOperation(expression, context) {\n  const left = evaluateExpression(expression.left, context);\n  const right = evaluateExpression(expression.right, context);\n  switch (expression.operator) {\n    case BinaryOperator.And:\n      {\n        return Boolean(left && right);\n      }\n    case BinaryOperator.Or:\n      {\n        return Boolean(left || right);\n      }\n    case BinaryOperator.Equals:\n      {\n        return isLooseEqual(left, right);\n      }\n    case BinaryOperator.NotEquals:\n      {\n        return !isLooseEqual(left, right);\n      }\n    case BinaryOperator.LessThan:\n      {\n        if (isNumber(left) && isNumber(right)) {\n          return left < right;\n        }\n        if (isValidDate(left) && isValidDate(right)) {\n          return left < right;\n        }\n        return false;\n      }\n    case BinaryOperator.LessThanOrEqual:\n      {\n        if (isNumber(left) && isNumber(right)) {\n          return left <= right;\n        }\n        if (isValidDate(left) && isValidDate(right)) {\n          return left <= right;\n        }\n        return false;\n      }\n    case BinaryOperator.GreaterThan:\n      {\n        if (isNumber(left) && isNumber(right)) {\n          return left > right;\n        }\n        if (isValidDate(left) && isValidDate(right)) {\n          return left > right;\n        }\n        return false;\n      }\n    case BinaryOperator.GreaterThanOrEqual:\n      {\n        if (isNumber(left) && isNumber(right)) {\n          return left >= right;\n        }\n        if (isValidDate(left) && isValidDate(right)) {\n          return left >= right;\n        }\n        return false;\n      }\n    default:\n      {\n        throw new Error(`Unsupported binary operation: ${expression.operator}`);\n      }\n  }\n}\nfunction evaluateTypeCast(expression, context) {\n  const value = evaluateExpression(expression.value, context);\n  switch (expression.dataType) {\n    case \"BOOLEAN\":\n      {\n        return Boolean(value);\n      }\n    case \"NUMBER\":\n      {\n        if (isNumber(value) && isFinite(value)) {\n          return value;\n        }\n        if (isString(value)) {\n          const parsed = parseFloat(value);\n          if (isFinite(parsed)) {\n            return parsed;\n          }\n        }\n        return 0;\n      }\n    case \"DATE\":\n      {\n        if (value instanceof Date) return value;\n        if (!isString(value) && !isNumber(value)) {\n          return undefined;\n        }\n        return new Date(value);\n      }\n    case \"STRING\":\n      {\n        return String(value);\n      }\n    default:\n      {\n        throw new Error(`Unsupported type cast: ${expression.dataType}`);\n      }\n  }\n}\n/**\n * Creates a string representation of an expression. This is used if there is no\n * alias in a select expression.\n */\nfunction stringifyExpression(expression) {\n  switch (expression.type) {\n    case \"Identifier\":\n      {\n        return expression.name;\n      }\n    default:\n      {\n        throw new Error(`Can't stringify expression: ${JSON.stringify(expression)}`);\n      }\n  }\n}\n/**\n * Checks for equality of two values with the exception that:\n * - null and undefined are equal\n * - strings are case insensitive\n */\nfunction isLooseEqual(left, right) {\n  // If both values are nullish (null or undefined) return true.\n  if (left == null && right == null) {\n    return true;\n  }\n  if (isString(left) && isString(right)) {\n    return left.toLowerCase() === right.toLowerCase();\n  }\n  if (isValidDate(left) && isValidDate(right)) {\n    return left.getTime() === right.getTime();\n  }\n  return left === right;\n}\n/** Utility function to create a WHERE expression from path variables. */\nexport function getWhereExpressionFromPathVariables(pathVariables) {\n  const entries = Object.entries(pathVariables).filter(([, value]) => {\n    if (isUndefined(value)) return false;\n    if (isObject(value)) return false;\n    return true;\n  });\n  const expressions = entries.map(([name, value]) => ({\n    type: \"BinaryOperation\",\n    operator: BinaryOperator.Equals,\n    left: {\n      type: \"TypeCast\",\n      value: {\n        type: \"Identifier\",\n        name\n      },\n      dataType: \"STRING\"\n    },\n    right: {\n      type: \"LiteralValue\",\n      value: String(value)\n    }\n  }));\n  if (expressions.length === 0) {\n    return {\n      type: \"LiteralValue\",\n      value: false\n    };\n  }\n  return expressions.reduce((result, expression) => ({\n    type: \"BinaryOperation\",\n    operator: BinaryOperator.And,\n    left: result,\n    right: expression\n  }));\n}","map":{"version":3,"names":["useRef","isEqual","isArray","isNumber","isObject","isString","isUndefined","isValidDate","LazyValue","DeepWeakMap","map1","WeakMap","get","key1","key2","map2","set","value","UnaryOperator","BinaryOperator","OrderDirection","useData","from","data","locale","promise","preload","read","indexCache","useInsertIndex","cached","result","map","item","index","whereCache","useExecuteWhere","where","filter","evaluateExpression","resolveIdentifier","identifier","orderByCache","useExecuteOrderBy","orderBy","sort","leftItem","rightItem","order","expression","leftValue","rightValue","localeCompare","direction","Descending","offsetCache","useExecuteOffset","offset","offsetValue","Error","slice","limitCache","useExecuteLimit","limit","limitValue","selectCache","useExecuteSelect","select","preloadPromise","preloadExpressions","selected","name","alias","stringifyExpression","is","expressions","identifiers","extractIdentifiers","length","preloadPromises","push","Promise","all","type","argument","arguments","condition","conditions","when","then","else","left","right","useQueryData","query","queryRef","current","context","evaluateFunctionCall","evaluateCase","evaluateUnaryOperation","evaluateBinaryOperation","evaluateTypeCast","JSON","stringify","getArgument","functionName","search","toLowerCase","includes","startsWith","endsWith","isLooseEqual","operator","Not","And","Boolean","Or","Equals","NotEquals","LessThan","LessThanOrEqual","GreaterThan","GreaterThanOrEqual","dataType","isFinite","parsed","parseFloat","Date","undefined","String","getTime","getWhereExpressionFromPathVariables","pathVariables","entries","Object","reduce"],"sources":["../../src/modules/useQueryData.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}